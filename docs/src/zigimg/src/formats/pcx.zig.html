<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>src/formats/pcx.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">// Adapted from https://github.com/MasterQ32/zig-gamedev-lib/blob/master/src/pcx.zig</span>
</span>
<span class="line" id="L2"><span class="tok-comment">// with permission from Felix Quei√üner</span>
</span>
<span class="line" id="L3"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> buffered_stream_source = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../buffered_stream_source.zig&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> color = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../color.zig&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> FormatInterface = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../FormatInterface.zig&quot;</span>);</span>
<span class="line" id="L7"><span class="tok-kw">const</span> Image = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../Image.zig&quot;</span>);</span>
<span class="line" id="L8"><span class="tok-kw">const</span> ImageError = Image.Error;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> ImageReadError = Image.ReadError;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> ImageWriteError = Image.WriteError;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> PixelFormat = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../pixel_format.zig&quot;</span>).PixelFormat;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L13"><span class="tok-kw">const</span> utils = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../utils.zig&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">const</span> simd = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../simd.zig&quot;</span>);</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-kw">const</span> MagicHeader: <span class="tok-type">u8</span> = <span class="tok-number">0x0A</span>;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> Version: <span class="tok-type">u8</span> = <span class="tok-number">5</span>;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> VGAPaletteIdentifier: <span class="tok-type">u8</span> = <span class="tok-number">0x0C</span>;</span>
<span class="line" id="L19"></span>
<span class="line" id="L20"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Compression = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L21">    none,</span>
<span class="line" id="L22">    rle,</span>
<span class="line" id="L23">};</span>
<span class="line" id="L24"></span>
<span class="line" id="L25"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PaletteInfo = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {</span>
<span class="line" id="L26">    color = <span class="tok-number">1</span>,</span>
<span class="line" id="L27">    grayscale = <span class="tok-number">2</span>,</span>
<span class="line" id="L28">    _,</span>
<span class="line" id="L29">};</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PCXHeader = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L32">    id: <span class="tok-type">u8</span> = MagicHeader,</span>
<span class="line" id="L33">    version: <span class="tok-type">u8</span> = Version,</span>
<span class="line" id="L34">    compression: Compression = .rle,</span>
<span class="line" id="L35">    bpp: <span class="tok-type">u8</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L36">    xmin: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L37">    ymin: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L38">    xmax: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L39">    ymax: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L40">    horizontal_dpi: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">320</span>, <span class="tok-comment">// Default values found in the PCX image in the test suite</span>
</span>
<span class="line" id="L41">    vertical_dpi: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">200</span>, <span class="tok-comment">// Default values found in the PCX image in the test suite</span>
</span>
<span class="line" id="L42">    builtin_palette: [<span class="tok-number">16</span>]color.Rgb24 = [_]color.Rgb24{.{ .r = <span class="tok-number">0</span>, .g = <span class="tok-number">0</span>, .b = <span class="tok-number">0</span> }} ** <span class="tok-number">16</span>,</span>
<span class="line" id="L43">    _reserved0: <span class="tok-type">u8</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L44">    planes: <span class="tok-type">u8</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L45">    stride: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L46">    palette_information: PaletteInfo <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = .color,</span>
<span class="line" id="L47">    screen_width: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L48">    screen_height: <span class="tok-type">u16</span> <span class="tok-kw">align</span>(<span class="tok-number">1</span>) = <span class="tok-number">0</span>,</span>
<span class="line" id="L49">    padding: [<span class="tok-number">54</span>]<span class="tok-type">u8</span> = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">54</span>,</span>
<span class="line" id="L50"></span>
<span class="line" id="L51">    <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L52">        std.debug.assert(<span class="tok-builtin">@sizeOf</span>(PCXHeader) == <span class="tok-number">128</span>);</span>
<span class="line" id="L53">    }</span>
<span class="line" id="L54">};</span>
<span class="line" id="L55"></span>
<span class="line" id="L56"><span class="tok-kw">const</span> RLEPairMask = <span class="tok-number">0xC0</span>;</span>
<span class="line" id="L57"><span class="tok-kw">const</span> RLELengthMask = <span class="tok-number">0xFF</span> - RLEPairMask;</span>
<span class="line" id="L58"></span>
<span class="line" id="L59"><span class="tok-kw">const</span> RLEDecoder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L60">    <span class="tok-kw">const</span> Run = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L61">        value: <span class="tok-type">u8</span>,</span>
<span class="line" id="L62">        remaining: <span class="tok-type">usize</span>,</span>
<span class="line" id="L63">    };</span>
<span class="line" id="L64"></span>
<span class="line" id="L65">    reader: buffered_stream_source.DefaultBufferedStreamSourceReader.Reader,</span>
<span class="line" id="L66">    current_run: ?Run,</span>
<span class="line" id="L67"></span>
<span class="line" id="L68">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(reader: buffered_stream_source.DefaultBufferedStreamSourceReader.Reader) RLEDecoder {</span>
<span class="line" id="L69">        <span class="tok-kw">return</span> RLEDecoder{</span>
<span class="line" id="L70">            .reader = reader,</span>
<span class="line" id="L71">            .current_run = <span class="tok-null">null</span>,</span>
<span class="line" id="L72">        };</span>
<span class="line" id="L73">    }</span>
<span class="line" id="L74"></span>
<span class="line" id="L75">    <span class="tok-kw">fn</span> <span class="tok-fn">readByte</span>(self: *RLEDecoder) ImageReadError!<span class="tok-type">u8</span> {</span>
<span class="line" id="L76">        <span class="tok-kw">if</span> (self.current_run) |*run| {</span>
<span class="line" id="L77">            <span class="tok-kw">const</span> result = run.value;</span>
<span class="line" id="L78">            run.remaining -= <span class="tok-number">1</span>;</span>
<span class="line" id="L79">            <span class="tok-kw">if</span> (run.remaining == <span class="tok-number">0</span>) {</span>
<span class="line" id="L80">                self.current_run = <span class="tok-null">null</span>;</span>
<span class="line" id="L81">            }</span>
<span class="line" id="L82">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L83">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L84">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L85">                <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> self.reader.readByte();</span>
<span class="line" id="L86">                <span class="tok-kw">if</span> (byte == RLEPairMask) <span class="tok-comment">// skip over &quot;zero length runs&quot;</span>
</span>
<span class="line" id="L87">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L88">                <span class="tok-kw">if</span> ((byte &amp; RLEPairMask) == RLEPairMask) {</span>
<span class="line" id="L89">                    <span class="tok-kw">const</span> len = byte &amp; RLELengthMask;</span>
<span class="line" id="L90">                    std.debug.assert(len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L91">                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.reader.readByte();</span>
<span class="line" id="L92">                    <span class="tok-kw">if</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L93">                        <span class="tok-comment">// we only need to store a run in the decoder if it is longer than 1</span>
</span>
<span class="line" id="L94">                        self.current_run = .{</span>
<span class="line" id="L95">                            .value = result,</span>
<span class="line" id="L96">                            .remaining = len - <span class="tok-number">1</span>,</span>
<span class="line" id="L97">                        };</span>
<span class="line" id="L98">                    }</span>
<span class="line" id="L99">                    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L100">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L101">                    <span class="tok-kw">return</span> byte;</span>
<span class="line" id="L102">                }</span>
<span class="line" id="L103">            }</span>
<span class="line" id="L104">        }</span>
<span class="line" id="L105">    }</span>
<span class="line" id="L106"></span>
<span class="line" id="L107">    <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(decoder: RLEDecoder) ImageReadError!<span class="tok-type">void</span> {</span>
<span class="line" id="L108">        <span class="tok-kw">if</span> (decoder.current_run != <span class="tok-null">null</span>) {</span>
<span class="line" id="L109">            <span class="tok-kw">return</span> ImageReadError.InvalidData;</span>
<span class="line" id="L110">        }</span>
<span class="line" id="L111">    }</span>
<span class="line" id="L112">};</span>
<span class="line" id="L113"></span>
<span class="line" id="L114"><span class="tok-kw">const</span> RLEPair = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L115">    length: <span class="tok-type">u6</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L116">    identifier: <span class="tok-type">u2</span> = (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">2</span>) - <span class="tok-number">1</span>,</span>
<span class="line" id="L117">};</span>
<span class="line" id="L118"></span>
<span class="line" id="L119"><span class="tok-kw">const</span> RLEMinLength = <span class="tok-number">2</span>;</span>
<span class="line" id="L120"><span class="tok-kw">const</span> RLEMaxLength = (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">6</span>) - <span class="tok-number">1</span>;</span>
<span class="line" id="L121"></span>
<span class="line" id="L122"><span class="tok-kw">fn</span> <span class="tok-fn">flushRLE</span>(writer: <span class="tok-kw">anytype</span>, value: <span class="tok-type">u8</span>, count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L123">    <span class="tok-kw">var</span> current_count = count;</span>
<span class="line" id="L124">    <span class="tok-kw">while</span> (current_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L125">        <span class="tok-kw">const</span> length_to_write = <span class="tok-builtin">@min</span>(current_count, RLEMaxLength);</span>
<span class="line" id="L126"></span>
<span class="line" id="L127">        <span class="tok-kw">if</span> (length_to_write &gt;= RLEMinLength) {</span>
<span class="line" id="L128">            <span class="tok-kw">try</span> flushRlePair(writer, value, length_to_write);</span>
<span class="line" id="L129">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L130">            <span class="tok-kw">try</span> flushRawBytes(writer, value, length_to_write);</span>
<span class="line" id="L131">        }</span>
<span class="line" id="L132"></span>
<span class="line" id="L133">        current_count -= length_to_write;</span>
<span class="line" id="L134">    }</span>
<span class="line" id="L135">}</span>
<span class="line" id="L136"></span>
<span class="line" id="L137"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">flushRlePair</span>(writer: <span class="tok-kw">anytype</span>, value: <span class="tok-type">u8</span>, count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L138">    <span class="tok-kw">const</span> rle_pair = RLEPair{</span>
<span class="line" id="L139">        .length = <span class="tok-builtin">@truncate</span>(count),</span>
<span class="line" id="L140">    };</span>
<span class="line" id="L141">    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@bitCast</span>(rle_pair));</span>
<span class="line" id="L142">    <span class="tok-kw">try</span> writer.writeByte(value);</span>
<span class="line" id="L143">}</span>
<span class="line" id="L144"></span>
<span class="line" id="L145"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">flushRawBytes</span>(writer: <span class="tok-kw">anytype</span>, value: <span class="tok-type">u8</span>, count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L146">    <span class="tok-comment">// Must flush byte greater than 192 (0xC0) as a RLE pair</span>
</span>
<span class="line" id="L147">    <span class="tok-kw">if</span> ((value &amp; RLEPairMask) == RLEPairMask) {</span>
<span class="line" id="L148">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |_| {</span>
<span class="line" id="L149">            <span class="tok-kw">try</span> flushRlePair(writer, value, <span class="tok-number">1</span>);</span>
<span class="line" id="L150">        }</span>
<span class="line" id="L151">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L152">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |_| {</span>
<span class="line" id="L153">            <span class="tok-kw">try</span> writer.writeByte(value);</span>
<span class="line" id="L154">        }</span>
<span class="line" id="L155">    }</span>
<span class="line" id="L156">}</span>
<span class="line" id="L157"></span>
<span class="line" id="L158"><span class="tok-kw">const</span> RLEFastEncoder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L159">    <span class="tok-kw">const</span> LengthToCheck = <span class="tok-number">16</span>;</span>
<span class="line" id="L160">    <span class="tok-kw">const</span> VectorType = <span class="tok-builtin">@Vector</span>(LengthToCheck, <span class="tok-type">u8</span>);</span>
<span class="line" id="L161"></span>
<span class="line" id="L162">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encode</span>(source_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L163">        <span class="tok-kw">if</span> (source_data.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L164">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L165">        }</span>
<span class="line" id="L166"></span>
<span class="line" id="L167">        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">        <span class="tok-kw">var</span> total_similar_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L170"></span>
<span class="line" id="L171">        <span class="tok-kw">var</span> current_byte: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">        <span class="tok-kw">while</span> (index &lt; source_data.len <span class="tok-kw">and</span> (index + LengthToCheck) &lt;= source_data.len) {</span>
<span class="line" id="L174">            <span class="tok-comment">// Read current byte</span>
</span>
<span class="line" id="L175">            current_byte = source_data[index];</span>
<span class="line" id="L176"></span>
<span class="line" id="L177">            <span class="tok-kw">const</span> current_byte_splatted: VectorType = <span class="tok-builtin">@splat</span>(current_byte);</span>
<span class="line" id="L178">            <span class="tok-kw">const</span> compare_chunk = simd.load(source_data[index..], VectorType, <span class="tok-number">0</span>);</span>
<span class="line" id="L179"></span>
<span class="line" id="L180">            <span class="tok-kw">const</span> compare_mask = (current_byte_splatted == compare_chunk);</span>
<span class="line" id="L181">            <span class="tok-kw">const</span> inverted_mask = ~<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitCast</span>(compare_mask));</span>
<span class="line" id="L182">            <span class="tok-kw">const</span> current_similar_count = <span class="tok-builtin">@ctz</span>(inverted_mask);</span>
<span class="line" id="L183"></span>
<span class="line" id="L184">            <span class="tok-kw">if</span> (current_similar_count == LengthToCheck) {</span>
<span class="line" id="L185">                total_similar_count += current_similar_count;</span>
<span class="line" id="L186">                index += current_similar_count;</span>
<span class="line" id="L187">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L188">                total_similar_count += current_similar_count;</span>
<span class="line" id="L189"></span>
<span class="line" id="L190">                <span class="tok-kw">try</span> flushRLE(writer, current_byte, total_similar_count);</span>
<span class="line" id="L191"></span>
<span class="line" id="L192">                total_similar_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L193"></span>
<span class="line" id="L194">                index += current_similar_count;</span>
<span class="line" id="L195">            }</span>
<span class="line" id="L196">        }</span>
<span class="line" id="L197"></span>
<span class="line" id="L198">        <span class="tok-kw">try</span> flushRLE(writer, current_byte, total_similar_count);</span>
<span class="line" id="L199"></span>
<span class="line" id="L200">        <span class="tok-comment">// Process the rest sequentially</span>
</span>
<span class="line" id="L201">        total_similar_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L202">        <span class="tok-kw">if</span> (index &lt; source_data.len) {</span>
<span class="line" id="L203">            current_byte = source_data[index];</span>
<span class="line" id="L204"></span>
<span class="line" id="L205">            <span class="tok-kw">while</span> (index &lt; source_data.len) {</span>
<span class="line" id="L206">                <span class="tok-kw">const</span> read_byte = source_data[index];</span>
<span class="line" id="L207">                <span class="tok-kw">if</span> (read_byte == current_byte) {</span>
<span class="line" id="L208">                    total_similar_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L209">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L210">                    <span class="tok-kw">try</span> flushRLE(writer, current_byte, total_similar_count);</span>
<span class="line" id="L211"></span>
<span class="line" id="L212">                    current_byte = read_byte;</span>
<span class="line" id="L213">                    total_similar_count = <span class="tok-number">1</span>;</span>
<span class="line" id="L214">                }</span>
<span class="line" id="L215"></span>
<span class="line" id="L216">                index += <span class="tok-number">1</span>;</span>
<span class="line" id="L217">            }</span>
<span class="line" id="L218"></span>
<span class="line" id="L219">            <span class="tok-kw">try</span> flushRLE(writer, current_byte, total_similar_count);</span>
<span class="line" id="L220">        }</span>
<span class="line" id="L221">    }</span>
<span class="line" id="L222">};</span>
<span class="line" id="L223"></span>
<span class="line" id="L224"><span class="tok-kw">test</span> <span class="tok-str">&quot;PCX RLE Fast encoder&quot;</span> {</span>
<span class="line" id="L225">    <span class="tok-kw">const</span> uncompressed_data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">64</span>, <span class="tok-number">64</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">215</span>, <span class="tok-number">215</span>, <span class="tok-number">215</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>, <span class="tok-number">200</span>, <span class="tok-number">200</span>, <span class="tok-number">200</span>, <span class="tok-number">200</span>, <span class="tok-number">210</span>, <span class="tok-number">210</span> };</span>
<span class="line" id="L226">    <span class="tok-kw">const</span> compressed_data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xC9</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0xC2</span>, <span class="tok-number">0x40</span>, <span class="tok-number">0xC5</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0xC3</span>, <span class="tok-number">0xD7</span>, <span class="tok-number">0xCA</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0xC4</span>, <span class="tok-number">0xC8</span>, <span class="tok-number">0xC2</span>, <span class="tok-number">0xD2</span> };</span>
<span class="line" id="L227"></span>
<span class="line" id="L228">    <span class="tok-kw">var</span> result_list = std.ArrayList(<span class="tok-type">u8</span>).init(std.testing.allocator);</span>
<span class="line" id="L229">    <span class="tok-kw">defer</span> result_list.deinit();</span>
<span class="line" id="L230"></span>
<span class="line" id="L231">    <span class="tok-kw">const</span> writer = result_list.writer();</span>
<span class="line" id="L232"></span>
<span class="line" id="L233">    <span class="tok-kw">try</span> RLEFastEncoder.encode(uncompressed_data[<span class="tok-number">0</span>..], writer);</span>
<span class="line" id="L234"></span>
<span class="line" id="L235">    <span class="tok-kw">try</span> std.testing.expectEqualSlices(<span class="tok-type">u8</span>, compressed_data[<span class="tok-number">0</span>..], result_list.items);</span>
<span class="line" id="L236">}</span>
<span class="line" id="L237"></span>
<span class="line" id="L238"><span class="tok-kw">test</span> <span class="tok-str">&quot;PCX RLE Fast encoder should encore more than 63 bytes similar&quot;</span> {</span>
<span class="line" id="L239">    <span class="tok-kw">const</span> first_uncompressed_part = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x45</span>} ** <span class="tok-number">65</span>;</span>
<span class="line" id="L240">    <span class="tok-kw">const</span> second_uncompresse_part = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x1</span>, <span class="tok-number">0x1</span>, <span class="tok-number">0x1</span>, <span class="tok-number">0x1</span> };</span>
<span class="line" id="L241">    <span class="tok-kw">const</span> uncompressed_data = first_uncompressed_part ++ second_uncompresse_part;</span>
<span class="line" id="L242"></span>
<span class="line" id="L243">    <span class="tok-kw">const</span> compressed_data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xFF</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0xC4</span>, <span class="tok-number">0x1</span> };</span>
<span class="line" id="L244"></span>
<span class="line" id="L245">    <span class="tok-kw">var</span> result_list = std.ArrayList(<span class="tok-type">u8</span>).init(std.testing.allocator);</span>
<span class="line" id="L246">    <span class="tok-kw">defer</span> result_list.deinit();</span>
<span class="line" id="L247"></span>
<span class="line" id="L248">    <span class="tok-kw">const</span> writer = result_list.writer();</span>
<span class="line" id="L249"></span>
<span class="line" id="L250">    <span class="tok-kw">try</span> RLEFastEncoder.encode(uncompressed_data[<span class="tok-number">0</span>..], writer);</span>
<span class="line" id="L251"></span>
<span class="line" id="L252">    <span class="tok-kw">try</span> std.testing.expectEqualSlices(<span class="tok-type">u8</span>, compressed_data[<span class="tok-number">0</span>..], result_list.items);</span>
<span class="line" id="L253">}</span>
<span class="line" id="L254"></span>
<span class="line" id="L255"><span class="tok-kw">const</span> RLEStreamEncoder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L256">    rle_byte: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L257">    length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encode</span>(self: *RLEStreamEncoder, writer: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L260">        <span class="tok-kw">for</span> (bytes) |byte| {</span>
<span class="line" id="L261">            <span class="tok-kw">try</span> self.encodeByte(writer, byte);</span>
<span class="line" id="L262">        }</span>
<span class="line" id="L263">    }</span>
<span class="line" id="L264"></span>
<span class="line" id="L265">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encodeByte</span>(self: *RLEStreamEncoder, writer: <span class="tok-kw">anytype</span>, byte: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L266">        <span class="tok-kw">if</span> (self.rle_byte == <span class="tok-null">null</span>) {</span>
<span class="line" id="L267">            self.rle_byte = byte;</span>
<span class="line" id="L268">            self.length = <span class="tok-number">1</span>;</span>
<span class="line" id="L269">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L270">        }</span>
<span class="line" id="L271"></span>
<span class="line" id="L272">        <span class="tok-kw">if</span> (self.rle_byte) |rle_byte| {</span>
<span class="line" id="L273">            <span class="tok-kw">if</span> (rle_byte == byte) {</span>
<span class="line" id="L274">                self.length += <span class="tok-number">1</span>;</span>
<span class="line" id="L275">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L276">                <span class="tok-kw">try</span> flushRLE(writer, rle_byte, self.length);</span>
<span class="line" id="L277"></span>
<span class="line" id="L278">                self.length = <span class="tok-number">1</span>;</span>
<span class="line" id="L279">                self.rle_byte = byte;</span>
<span class="line" id="L280">            }</span>
<span class="line" id="L281">        }</span>
<span class="line" id="L282">    }</span>
<span class="line" id="L283"></span>
<span class="line" id="L284">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(self: *RLEStreamEncoder, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L285">        <span class="tok-kw">if</span> (self.length == <span class="tok-number">0</span>) {</span>
<span class="line" id="L286">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L287">        }</span>
<span class="line" id="L288"></span>
<span class="line" id="L289">        <span class="tok-kw">if</span> (self.rle_byte) |check_byte| {</span>
<span class="line" id="L290">            <span class="tok-kw">try</span> flushRLE(writer, check_byte, self.length);</span>
<span class="line" id="L291">        }</span>
<span class="line" id="L292">    }</span>
<span class="line" id="L293">};</span>
<span class="line" id="L294"></span>
<span class="line" id="L295"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PCX = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L296">    header: PCXHeader = .{},</span>
<span class="line" id="L297"></span>
<span class="line" id="L298">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EncoderOptions = <span class="tok-kw">struct</span> {};</span>
<span class="line" id="L299"></span>
<span class="line" id="L300">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">formatInterface</span>() FormatInterface {</span>
<span class="line" id="L301">        <span class="tok-kw">return</span> FormatInterface{</span>
<span class="line" id="L302">            .format = format,</span>
<span class="line" id="L303">            .formatDetect = formatDetect,</span>
<span class="line" id="L304">            .readImage = readImage,</span>
<span class="line" id="L305">            .writeImage = writeImage,</span>
<span class="line" id="L306">        };</span>
<span class="line" id="L307">    }</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>() Image.Format {</span>
<span class="line" id="L310">        <span class="tok-kw">return</span> Image.Format.pcx;</span>
<span class="line" id="L311">    }</span>
<span class="line" id="L312"></span>
<span class="line" id="L313">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">formatDetect</span>(stream: *Image.Stream) ImageReadError!<span class="tok-type">bool</span> {</span>
<span class="line" id="L314">        <span class="tok-kw">var</span> magic_number_bufffer: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L315">        _ = <span class="tok-kw">try</span> stream.read(magic_number_bufffer[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L316"></span>
<span class="line" id="L317">        <span class="tok-kw">if</span> (magic_number_bufffer[<span class="tok-number">0</span>] != MagicHeader) {</span>
<span class="line" id="L318">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L319">        }</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">        <span class="tok-kw">if</span> (magic_number_bufffer[<span class="tok-number">1</span>] &gt; Version) {</span>
<span class="line" id="L322">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L323">        }</span>
<span class="line" id="L324"></span>
<span class="line" id="L325">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L326">    }</span>
<span class="line" id="L327"></span>
<span class="line" id="L328">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readImage</span>(allocator: Allocator, stream: *Image.Stream) ImageReadError!Image {</span>
<span class="line" id="L329">        <span class="tok-kw">var</span> result = Image.init(allocator);</span>
<span class="line" id="L330">        <span class="tok-kw">errdefer</span> result.deinit();</span>
<span class="line" id="L331">        <span class="tok-kw">var</span> pcx = PCX{};</span>
<span class="line" id="L332"></span>
<span class="line" id="L333">        <span class="tok-kw">const</span> pixels = <span class="tok-kw">try</span> pcx.read(allocator, stream);</span>
<span class="line" id="L334"></span>
<span class="line" id="L335">        result.width = pcx.width();</span>
<span class="line" id="L336">        result.height = pcx.height();</span>
<span class="line" id="L337">        result.pixels = pixels;</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L340">    }</span>
<span class="line" id="L341"></span>
<span class="line" id="L342">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImage</span>(allocator: Allocator, stream: *Image.Stream, image: Image, encoder_options: Image.EncoderOptions) ImageWriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L343">        _ = allocator;</span>
<span class="line" id="L344">        _ = encoder_options;</span>
<span class="line" id="L345"></span>
<span class="line" id="L346">        <span class="tok-kw">var</span> pcx = PCX{};</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">        <span class="tok-kw">if</span> (image.width &gt; std.math.maxInt(<span class="tok-type">u16</span>) <span class="tok-kw">or</span> image.height &gt; std.math.maxInt(<span class="tok-type">u16</span>)) {</span>
<span class="line" id="L349">            <span class="tok-kw">return</span> ImageWriteError.Unsupported;</span>
<span class="line" id="L350">        }</span>
<span class="line" id="L351"></span>
<span class="line" id="L352">        pcx.header.xmax = <span class="tok-builtin">@truncate</span>(image.width - <span class="tok-number">1</span>);</span>
<span class="line" id="L353">        pcx.header.ymax = <span class="tok-builtin">@truncate</span>(image.height - <span class="tok-number">1</span>);</span>
<span class="line" id="L354"></span>
<span class="line" id="L355">        <span class="tok-comment">// Fill header info based on image</span>
</span>
<span class="line" id="L356">        <span class="tok-kw">switch</span> (image.pixels) {</span>
<span class="line" id="L357">            .indexed1 =&gt; |pixels| {</span>
<span class="line" id="L358">                pcx.header.bpp = <span class="tok-number">1</span>;</span>
<span class="line" id="L359">                pcx.header.planes = <span class="tok-number">1</span>;</span>
<span class="line" id="L360"></span>
<span class="line" id="L361">                pcx.fillPalette(pixels.palette);</span>
<span class="line" id="L362">            },</span>
<span class="line" id="L363">            .indexed4 =&gt; |pixels| {</span>
<span class="line" id="L364">                pcx.header.bpp = <span class="tok-number">4</span>;</span>
<span class="line" id="L365">                pcx.header.planes = <span class="tok-number">1</span>;</span>
<span class="line" id="L366"></span>
<span class="line" id="L367">                pcx.fillPalette(pixels.palette);</span>
<span class="line" id="L368">            },</span>
<span class="line" id="L369">            .indexed8 =&gt; {</span>
<span class="line" id="L370">                pcx.header.bpp = <span class="tok-number">8</span>;</span>
<span class="line" id="L371">                pcx.header.planes = <span class="tok-number">1</span>;</span>
<span class="line" id="L372">            },</span>
<span class="line" id="L373">            .rgb24 =&gt; {</span>
<span class="line" id="L374">                pcx.header.bpp = <span class="tok-number">8</span>;</span>
<span class="line" id="L375">                pcx.header.planes = <span class="tok-number">3</span>;</span>
<span class="line" id="L376">            },</span>
<span class="line" id="L377">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L378">                <span class="tok-kw">return</span> ImageWriteError.Unsupported;</span>
<span class="line" id="L379">            },</span>
<span class="line" id="L380">        }</span>
<span class="line" id="L381"></span>
<span class="line" id="L382">        pcx.header.stride = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromFloat</span>((<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@floatFromInt</span>(image.width)) / <span class="tok-number">8.0</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@floatFromInt</span>(pcx.header.bpp))));</span>
<span class="line" id="L383">        <span class="tok-comment">// Add one if the result is a odd number</span>
</span>
<span class="line" id="L384">        pcx.header.stride += (pcx.header.stride &amp; <span class="tok-number">0x1</span>);</span>
<span class="line" id="L385"></span>
<span class="line" id="L386">        <span class="tok-kw">try</span> pcx.write(stream, image.pixels);</span>
<span class="line" id="L387">    }</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pixelFormat</span>(self: PCX) ImageReadError!PixelFormat {</span>
<span class="line" id="L390">        <span class="tok-kw">if</span> (self.header.planes == <span class="tok-number">1</span>) {</span>
<span class="line" id="L391">            <span class="tok-kw">switch</span> (self.header.bpp) {</span>
<span class="line" id="L392">                <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span> PixelFormat.indexed1,</span>
<span class="line" id="L393">                <span class="tok-number">4</span> =&gt; <span class="tok-kw">return</span> PixelFormat.indexed4,</span>
<span class="line" id="L394">                <span class="tok-number">8</span> =&gt; <span class="tok-kw">return</span> PixelFormat.indexed8,</span>
<span class="line" id="L395">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> ImageError.Unsupported,</span>
<span class="line" id="L396">            }</span>
<span class="line" id="L397">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.header.planes == <span class="tok-number">3</span>) {</span>
<span class="line" id="L398">            <span class="tok-kw">switch</span> (self.header.bpp) {</span>
<span class="line" id="L399">                <span class="tok-number">8</span> =&gt; <span class="tok-kw">return</span> PixelFormat.rgb24,</span>
<span class="line" id="L400">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> ImageError.Unsupported,</span>
<span class="line" id="L401">            }</span>
<span class="line" id="L402">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L403">            <span class="tok-kw">return</span> ImageError.Unsupported;</span>
<span class="line" id="L404">        }</span>
<span class="line" id="L405">    }</span>
<span class="line" id="L406"></span>
<span class="line" id="L407">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">width</span>(self: PCX) <span class="tok-type">usize</span> {</span>
<span class="line" id="L408">        <span class="tok-kw">return</span> self.header.xmax - self.header.xmin + <span class="tok-number">1</span>;</span>
<span class="line" id="L409">    }</span>
<span class="line" id="L410"></span>
<span class="line" id="L411">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">height</span>(self: PCX) <span class="tok-type">usize</span> {</span>
<span class="line" id="L412">        <span class="tok-kw">return</span> self.header.ymax - self.header.ymin + <span class="tok-number">1</span>;</span>
<span class="line" id="L413">    }</span>
<span class="line" id="L414"></span>
<span class="line" id="L415">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: *PCX, allocator: Allocator, stream: *Image.Stream) ImageReadError!color.PixelStorage {</span>
<span class="line" id="L416">        <span class="tok-kw">var</span> buffered_stream = buffered_stream_source.bufferedStreamSourceReader(stream);</span>
<span class="line" id="L417">        <span class="tok-kw">const</span> reader = buffered_stream.reader();</span>
<span class="line" id="L418">        self.header = <span class="tok-kw">try</span> utils.readStruct(reader, PCXHeader, .little);</span>
<span class="line" id="L419"></span>
<span class="line" id="L420">        <span class="tok-kw">if</span> (self.header.id != <span class="tok-number">0x0A</span>) {</span>
<span class="line" id="L421">            <span class="tok-kw">return</span> ImageReadError.InvalidData;</span>
<span class="line" id="L422">        }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">        <span class="tok-kw">if</span> (self.header.version &gt; <span class="tok-number">0x05</span>) {</span>
<span class="line" id="L425">            <span class="tok-kw">return</span> ImageReadError.InvalidData;</span>
<span class="line" id="L426">        }</span>
<span class="line" id="L427"></span>
<span class="line" id="L428">        <span class="tok-kw">if</span> (self.header.planes &gt; <span class="tok-number">3</span>) {</span>
<span class="line" id="L429">            <span class="tok-kw">return</span> ImageError.Unsupported;</span>
<span class="line" id="L430">        }</span>
<span class="line" id="L431"></span>
<span class="line" id="L432">        <span class="tok-kw">const</span> pixel_format = <span class="tok-kw">try</span> self.pixelFormat();</span>
<span class="line" id="L433"></span>
<span class="line" id="L434">        <span class="tok-kw">const</span> image_width = self.width();</span>
<span class="line" id="L435">        <span class="tok-kw">const</span> image_height = self.height();</span>
<span class="line" id="L436"></span>
<span class="line" id="L437">        <span class="tok-kw">const</span> has_dummy_byte = (<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-builtin">@bitCast</span>(self.header.stride)) - <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(image_width))) == <span class="tok-number">1</span>;</span>
<span class="line" id="L438">        <span class="tok-kw">const</span> actual_width = <span class="tok-kw">if</span> (has_dummy_byte) image_width + <span class="tok-number">1</span> <span class="tok-kw">else</span> image_width;</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">        <span class="tok-kw">var</span> pixels = <span class="tok-kw">try</span> color.PixelStorage.init(allocator, pixel_format, image_width * image_height);</span>
<span class="line" id="L441">        <span class="tok-kw">errdefer</span> pixels.deinit(allocator);</span>
<span class="line" id="L442"></span>
<span class="line" id="L443">        <span class="tok-kw">var</span> decoder = RLEDecoder.init(reader);</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">        <span class="tok-kw">const</span> scanline_length = (self.header.stride * self.header.planes);</span>
<span class="line" id="L446"></span>
<span class="line" id="L447">        <span class="tok-kw">var</span> y: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L448">        <span class="tok-kw">while</span> (y &lt; image_height) : (y += <span class="tok-number">1</span>) {</span>
<span class="line" id="L449">            <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L450">            <span class="tok-kw">var</span> x: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L451"></span>
<span class="line" id="L452">            <span class="tok-kw">const</span> y_stride = y * image_width;</span>
<span class="line" id="L453"></span>
<span class="line" id="L454">            <span class="tok-comment">// read all pixels from the current row</span>
</span>
<span class="line" id="L455">            <span class="tok-kw">while</span> (offset &lt; scanline_length <span class="tok-kw">and</span> x &lt; image_width) : (offset += <span class="tok-number">1</span>) {</span>
<span class="line" id="L456">                <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> decoder.readByte();</span>
<span class="line" id="L457">                <span class="tok-kw">switch</span> (pixels) {</span>
<span class="line" id="L458">                    .indexed1 =&gt; |storage| {</span>
<span class="line" id="L459">                        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L460">                        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L461">                            <span class="tok-kw">if</span> (x &lt; image_width) {</span>
<span class="line" id="L462">                                storage.indices[y_stride + x] = <span class="tok-builtin">@intCast</span>((byte &gt;&gt; (<span class="tok-number">7</span> - <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(i)))) &amp; <span class="tok-number">0x01</span>);</span>
<span class="line" id="L463">                                x += <span class="tok-number">1</span>;</span>
<span class="line" id="L464">                            }</span>
<span class="line" id="L465">                        }</span>
<span class="line" id="L466">                    },</span>
<span class="line" id="L467">                    .indexed4 =&gt; |storage| {</span>
<span class="line" id="L468">                        storage.indices[y_stride + x] = <span class="tok-builtin">@truncate</span>(byte &gt;&gt; <span class="tok-number">4</span>);</span>
<span class="line" id="L469">                        x += <span class="tok-number">1</span>;</span>
<span class="line" id="L470">                        <span class="tok-kw">if</span> (x &lt; image_width) {</span>
<span class="line" id="L471">                            storage.indices[y_stride + x] = <span class="tok-builtin">@truncate</span>(byte);</span>
<span class="line" id="L472">                            x += <span class="tok-number">1</span>;</span>
<span class="line" id="L473">                        }</span>
<span class="line" id="L474">                    },</span>
<span class="line" id="L475">                    .indexed8 =&gt; |storage| {</span>
<span class="line" id="L476">                        storage.indices[y_stride + x] = byte;</span>
<span class="line" id="L477">                        x += <span class="tok-number">1</span>;</span>
<span class="line" id="L478">                    },</span>
<span class="line" id="L479">                    .rgb24 =&gt; |storage| {</span>
<span class="line" id="L480">                        <span class="tok-kw">if</span> (has_dummy_byte <span class="tok-kw">and</span> byte == <span class="tok-number">0x00</span>) {</span>
<span class="line" id="L481">                            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L482">                        }</span>
<span class="line" id="L483">                        <span class="tok-kw">const</span> pixel_x = offset % (actual_width);</span>
<span class="line" id="L484">                        <span class="tok-kw">const</span> current_color = offset / (actual_width);</span>
<span class="line" id="L485">                        <span class="tok-kw">switch</span> (current_color) {</span>
<span class="line" id="L486">                            <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L487">                                storage[y_stride + pixel_x].r = byte;</span>
<span class="line" id="L488">                            },</span>
<span class="line" id="L489">                            <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L490">                                storage[y_stride + pixel_x].g = byte;</span>
<span class="line" id="L491">                            },</span>
<span class="line" id="L492">                            <span class="tok-number">2</span> =&gt; {</span>
<span class="line" id="L493">                                storage[y_stride + pixel_x].b = byte;</span>
<span class="line" id="L494">                            },</span>
<span class="line" id="L495">                            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L496">                        }</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">                        <span class="tok-kw">if</span> (pixel_x &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> (pixel_x % self.header.planes) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L499">                            x += <span class="tok-number">1</span>;</span>
<span class="line" id="L500">                        }</span>
<span class="line" id="L501">                    },</span>
<span class="line" id="L502">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> ImageError.Unsupported,</span>
<span class="line" id="L503">                }</span>
<span class="line" id="L504">            }</span>
<span class="line" id="L505"></span>
<span class="line" id="L506">            <span class="tok-comment">// discard the rest of the bytes in the current row</span>
</span>
<span class="line" id="L507">            <span class="tok-kw">while</span> (offset &lt; self.header.stride) : (offset += <span class="tok-number">1</span>) {</span>
<span class="line" id="L508">                _ = <span class="tok-kw">try</span> decoder.readByte();</span>
<span class="line" id="L509">            }</span>
<span class="line" id="L510">        }</span>
<span class="line" id="L511"></span>
<span class="line" id="L512">        <span class="tok-kw">try</span> decoder.finish();</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">        <span class="tok-kw">if</span> (pixel_format == .indexed1 <span class="tok-kw">or</span> pixel_format == .indexed4 <span class="tok-kw">or</span> pixel_format == .indexed8) {</span>
<span class="line" id="L515">            <span class="tok-kw">var</span> palette = <span class="tok-kw">switch</span> (pixels) {</span>
<span class="line" id="L516">                .indexed1 =&gt; |*storage| storage.palette[<span class="tok-number">0</span>..],</span>
<span class="line" id="L517">                .indexed4 =&gt; |*storage| storage.palette[<span class="tok-number">0</span>..],</span>
<span class="line" id="L518">                .indexed8 =&gt; |*storage| storage.palette[<span class="tok-number">0</span>..],</span>
<span class="line" id="L519">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L520">            };</span>
<span class="line" id="L521"></span>
<span class="line" id="L522">            <span class="tok-kw">const</span> effective_len = <span class="tok-builtin">@min</span>(palette.len, self.header.builtin_palette.len);</span>
<span class="line" id="L523">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..effective_len) |index| {</span>
<span class="line" id="L524">                palette[index].r = self.header.builtin_palette[index].r;</span>
<span class="line" id="L525">                palette[index].g = self.header.builtin_palette[index].g;</span>
<span class="line" id="L526">                palette[index].b = self.header.builtin_palette[index].b;</span>
<span class="line" id="L527">                palette[index].a = <span class="tok-number">255</span>;</span>
<span class="line" id="L528">            }</span>
<span class="line" id="L529"></span>
<span class="line" id="L530">            <span class="tok-kw">if</span> (pixels == .indexed8) {</span>
<span class="line" id="L531">                <span class="tok-kw">const</span> end_pos = <span class="tok-kw">try</span> buffered_stream.getEndPos();</span>
<span class="line" id="L532">                <span class="tok-kw">try</span> buffered_stream.seekTo(end_pos - <span class="tok-number">769</span>);</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">                <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> reader.readByte()) != VGAPaletteIdentifier) {</span>
<span class="line" id="L535">                    <span class="tok-kw">return</span> ImageReadError.InvalidData;</span>
<span class="line" id="L536">                }</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">                <span class="tok-kw">for</span> (palette) |*current_entry| {</span>
<span class="line" id="L539">                    current_entry.r = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L540">                    current_entry.g = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L541">                    current_entry.b = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L542">                    current_entry.a = <span class="tok-number">255</span>;</span>
<span class="line" id="L543">                }</span>
<span class="line" id="L544">            }</span>
<span class="line" id="L545">        }</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">        <span class="tok-kw">return</span> pixels;</span>
<span class="line" id="L548">    }</span>
<span class="line" id="L549"></span>
<span class="line" id="L550">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: PCX, stream: *Image.Stream, pixels: color.PixelStorage) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L551">        <span class="tok-kw">switch</span> (pixels) {</span>
<span class="line" id="L552">            .indexed1,</span>
<span class="line" id="L553">            .indexed4,</span>
<span class="line" id="L554">            .indexed8,</span>
<span class="line" id="L555">            .rgb24,</span>
<span class="line" id="L556">            =&gt; {</span>
<span class="line" id="L557">                <span class="tok-comment">// Do nothing</span>
</span>
<span class="line" id="L558">            },</span>
<span class="line" id="L559">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L560">                <span class="tok-kw">return</span> ImageWriteError.Unsupported;</span>
<span class="line" id="L561">            },</span>
<span class="line" id="L562">        }</span>
<span class="line" id="L563"></span>
<span class="line" id="L564">        <span class="tok-kw">var</span> buffered_stream = buffered_stream_source.bufferedStreamSourceWriter(stream);</span>
<span class="line" id="L565"></span>
<span class="line" id="L566">        <span class="tok-kw">const</span> writer = buffered_stream.writer();</span>
<span class="line" id="L567"></span>
<span class="line" id="L568">        <span class="tok-kw">try</span> utils.writeStruct(writer, self.header, .little);</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">        <span class="tok-kw">const</span> actual_width = self.width();</span>
<span class="line" id="L571">        <span class="tok-kw">const</span> is_even = ((actual_width &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L572"></span>
<span class="line" id="L573">        <span class="tok-kw">switch</span> (pixels) {</span>
<span class="line" id="L574">            .indexed1 =&gt; |indexed| {</span>
<span class="line" id="L575">                <span class="tok-kw">try</span> self.writeIndexed1(writer, indexed);</span>
<span class="line" id="L576">            },</span>
<span class="line" id="L577">            .indexed4 =&gt; |indexed| {</span>
<span class="line" id="L578">                <span class="tok-kw">try</span> self.writeIndexed4(writer, indexed);</span>
<span class="line" id="L579">            },</span>
<span class="line" id="L580">            .indexed8 =&gt; |indexed| {</span>
<span class="line" id="L581">                <span class="tok-kw">if</span> (is_even) {</span>
<span class="line" id="L582">                    <span class="tok-kw">try</span> writeIndexed8Even(writer, indexed);</span>
<span class="line" id="L583">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L584">                    <span class="tok-kw">try</span> self.writeIndexed8Odd(writer, indexed);</span>
<span class="line" id="L585">                }</span>
<span class="line" id="L586"></span>
<span class="line" id="L587">                <span class="tok-comment">// Write VGA palette</span>
</span>
<span class="line" id="L588">                <span class="tok-kw">try</span> writer.writeByte(VGAPaletteIdentifier);</span>
<span class="line" id="L589">                <span class="tok-kw">for</span> (pixels.indexed8.palette) |current_entry| {</span>
<span class="line" id="L590">                    <span class="tok-kw">const</span> rgb24_color = color.Rgb24.fromU32Rgba(current_entry.toU32Rgba());</span>
<span class="line" id="L591">                    <span class="tok-kw">try</span> utils.writeStruct(writer, rgb24_color, .little);</span>
<span class="line" id="L592">                }</span>
<span class="line" id="L593">            },</span>
<span class="line" id="L594">            .rgb24 =&gt; |data| {</span>
<span class="line" id="L595">                <span class="tok-kw">try</span> self.writeRgb24(writer, data);</span>
<span class="line" id="L596">            },</span>
<span class="line" id="L597">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L598">                <span class="tok-kw">return</span> ImageWriteError.Unsupported;</span>
<span class="line" id="L599">            },</span>
<span class="line" id="L600">        }</span>
<span class="line" id="L601"></span>
<span class="line" id="L602">        <span class="tok-kw">try</span> buffered_stream.flush();</span>
<span class="line" id="L603">    }</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">    <span class="tok-kw">fn</span> <span class="tok-fn">fillPalette</span>(self: *PCX, palette: []<span class="tok-kw">const</span> color.Rgba32) <span class="tok-type">void</span> {</span>
<span class="line" id="L606">        <span class="tok-kw">const</span> effective_len = <span class="tok-builtin">@min</span>(palette.len, self.header.builtin_palette.len);</span>
<span class="line" id="L607">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..effective_len) |index| {</span>
<span class="line" id="L608">            self.header.builtin_palette[index].r = palette[index].r;</span>
<span class="line" id="L609">            self.header.builtin_palette[index].g = palette[index].g;</span>
<span class="line" id="L610">            self.header.builtin_palette[index].b = palette[index].b;</span>
<span class="line" id="L611">        }</span>
<span class="line" id="L612">    }</span>
<span class="line" id="L613"></span>
<span class="line" id="L614">    <span class="tok-kw">fn</span> <span class="tok-fn">writeIndexed1</span>(self: *<span class="tok-kw">const</span> PCX, writer: buffered_stream_source.DefaultBufferedStreamSourceWriter.Writer, indexed: color.IndexedStorage1) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L615">        <span class="tok-kw">var</span> rle_encoder = RLEStreamEncoder{};</span>
<span class="line" id="L616"></span>
<span class="line" id="L617">        <span class="tok-kw">const</span> image_width = self.width();</span>
<span class="line" id="L618">        <span class="tok-kw">const</span> image_height = self.height();</span>
<span class="line" id="L619"></span>
<span class="line" id="L620">        <span class="tok-kw">const</span> is_even = ((image_width &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_height) |y| {</span>
<span class="line" id="L623">            <span class="tok-kw">const</span> stride = y * image_width;</span>
<span class="line" id="L624"></span>
<span class="line" id="L625">            <span class="tok-kw">var</span> current_byte: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L626"></span>
<span class="line" id="L627">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_width) |x| {</span>
<span class="line" id="L628">                <span class="tok-kw">const</span> pixel = indexed.indices[stride + x];</span>
<span class="line" id="L629"></span>
<span class="line" id="L630">                <span class="tok-kw">const</span> bit = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">7</span> - (x % <span class="tok-number">8</span>)));</span>
<span class="line" id="L631"></span>
<span class="line" id="L632">                current_byte |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, pixel) &lt;&lt; bit;</span>
<span class="line" id="L633">                <span class="tok-kw">if</span> (bit == <span class="tok-number">0</span>) {</span>
<span class="line" id="L634">                    <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_byte);</span>
<span class="line" id="L635">                    current_byte = <span class="tok-number">0</span>;</span>
<span class="line" id="L636">                }</span>
<span class="line" id="L637">            }</span>
<span class="line" id="L638"></span>
<span class="line" id="L639">            <span class="tok-kw">if</span> (!is_even) {</span>
<span class="line" id="L640">                <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_byte);</span>
<span class="line" id="L641">            }</span>
<span class="line" id="L642">        }</span>
<span class="line" id="L643"></span>
<span class="line" id="L644">        <span class="tok-kw">try</span> rle_encoder.flush(writer);</span>
<span class="line" id="L645">    }</span>
<span class="line" id="L646"></span>
<span class="line" id="L647">    <span class="tok-kw">fn</span> <span class="tok-fn">writeIndexed4</span>(self: *<span class="tok-kw">const</span> PCX, writer: buffered_stream_source.DefaultBufferedStreamSourceWriter.Writer, indexed: color.IndexedStorage4) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L648">        <span class="tok-kw">var</span> rle_encoder = RLEStreamEncoder{};</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">        <span class="tok-kw">const</span> image_width = self.width();</span>
<span class="line" id="L651">        <span class="tok-kw">const</span> image_height = self.height();</span>
<span class="line" id="L652"></span>
<span class="line" id="L653">        <span class="tok-kw">const</span> is_even = ((image_width &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L654"></span>
<span class="line" id="L655">        <span class="tok-kw">var</span> current_byte: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L656"></span>
<span class="line" id="L657">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_height) |y| {</span>
<span class="line" id="L658">            <span class="tok-kw">const</span> stride = y * image_width;</span>
<span class="line" id="L659"></span>
<span class="line" id="L660">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_width) |x| {</span>
<span class="line" id="L661">                <span class="tok-kw">const</span> pixel = indexed.indices[stride + x];</span>
<span class="line" id="L662"></span>
<span class="line" id="L663">                <span class="tok-kw">if</span> ((x &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0x1</span>) {</span>
<span class="line" id="L664">                    current_byte |= pixel;</span>
<span class="line" id="L665">                    <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_byte);</span>
<span class="line" id="L666">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L667">                    current_byte = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, pixel) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L668">                }</span>
<span class="line" id="L669">            }</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">            <span class="tok-kw">if</span> (!is_even) {</span>
<span class="line" id="L672">                <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_byte);</span>
<span class="line" id="L673">            }</span>
<span class="line" id="L674">        }</span>
<span class="line" id="L675"></span>
<span class="line" id="L676">        <span class="tok-kw">try</span> rle_encoder.flush(writer);</span>
<span class="line" id="L677">    }</span>
<span class="line" id="L678"></span>
<span class="line" id="L679">    <span class="tok-kw">fn</span> <span class="tok-fn">writeIndexed8Even</span>(writer: buffered_stream_source.DefaultBufferedStreamSourceWriter.Writer, indexed: color.IndexedStorage8) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L680">        <span class="tok-kw">try</span> RLEFastEncoder.encode(indexed.indices, writer);</span>
<span class="line" id="L681">    }</span>
<span class="line" id="L682"></span>
<span class="line" id="L683">    <span class="tok-kw">fn</span> <span class="tok-fn">writeIndexed8Odd</span>(self: *<span class="tok-kw">const</span> PCX, writer: buffered_stream_source.DefaultBufferedStreamSourceWriter.Writer, indexed: color.IndexedStorage8) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L684">        <span class="tok-kw">var</span> rle_encoder = RLEStreamEncoder{};</span>
<span class="line" id="L685"></span>
<span class="line" id="L686">        <span class="tok-kw">const</span> image_width = self.width();</span>
<span class="line" id="L687">        <span class="tok-kw">const</span> image_height = self.height();</span>
<span class="line" id="L688"></span>
<span class="line" id="L689">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_height) |y| {</span>
<span class="line" id="L690">            <span class="tok-kw">const</span> y_stride = y * image_width;</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">            <span class="tok-kw">const</span> pixel_stride = indexed.indices[y_stride..(y_stride + image_width)];</span>
<span class="line" id="L693">            <span class="tok-kw">try</span> rle_encoder.encode(writer, pixel_stride);</span>
<span class="line" id="L694">            <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, <span class="tok-number">0x00</span>);</span>
<span class="line" id="L695">        }</span>
<span class="line" id="L696"></span>
<span class="line" id="L697">        <span class="tok-kw">try</span> rle_encoder.flush(writer);</span>
<span class="line" id="L698">    }</span>
<span class="line" id="L699"></span>
<span class="line" id="L700">    <span class="tok-kw">fn</span> <span class="tok-fn">writeRgb24</span>(self: *<span class="tok-kw">const</span> PCX, writer: buffered_stream_source.DefaultBufferedStreamSourceWriter.Writer, pixels: []<span class="tok-kw">const</span> color.Rgb24) Image.WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L701">        <span class="tok-kw">var</span> rle_encoder = RLEStreamEncoder{};</span>
<span class="line" id="L702"></span>
<span class="line" id="L703">        <span class="tok-kw">const</span> image_width = self.width();</span>
<span class="line" id="L704">        <span class="tok-kw">const</span> image_height = self.height();</span>
<span class="line" id="L705"></span>
<span class="line" id="L706">        <span class="tok-kw">const</span> is_even = ((image_width &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L707"></span>
<span class="line" id="L708">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_height) |y| {</span>
<span class="line" id="L709">            <span class="tok-kw">const</span> stride = y * image_width;</span>
<span class="line" id="L710"></span>
<span class="line" id="L711">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">3</span>) |plane| {</span>
<span class="line" id="L712">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..image_width) |x| {</span>
<span class="line" id="L713">                    <span class="tok-kw">const</span> current_color = pixels[stride + x];</span>
<span class="line" id="L714">                    <span class="tok-kw">switch</span> (plane) {</span>
<span class="line" id="L715">                        <span class="tok-number">0</span> =&gt; <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_color.r),</span>
<span class="line" id="L716">                        <span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_color.g),</span>
<span class="line" id="L717">                        <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, current_color.b),</span>
<span class="line" id="L718">                        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L719">                    }</span>
<span class="line" id="L720">                }</span>
<span class="line" id="L721"></span>
<span class="line" id="L722">                <span class="tok-kw">if</span> (!is_even) {</span>
<span class="line" id="L723">                    <span class="tok-kw">try</span> rle_encoder.encodeByte(writer, <span class="tok-number">0x00</span>);</span>
<span class="line" id="L724">                }</span>
<span class="line" id="L725">            }</span>
<span class="line" id="L726">        }</span>
<span class="line" id="L727"></span>
<span class="line" id="L728">        <span class="tok-kw">try</span> rle_encoder.flush(writer);</span>
<span class="line" id="L729">    }</span>
<span class="line" id="L730">};</span>
<span class="line" id="L731"></span>
</code></pre></body>
</html>