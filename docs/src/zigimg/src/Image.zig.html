<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>src/Image.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> AllImageFormats = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;formats/all.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> FormatInterface = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;FormatInterface.zig&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> PixelFormat = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;pixel_format.zig&quot;</span>).PixelFormat;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> color = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;color.zig&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> utils = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;utils.zig&quot;</span>);</span>
<span class="line" id="L7"></span>
<span class="line" id="L8"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{</span>
<span class="line" id="L9">    Unsupported,</span>
<span class="line" id="L10">};</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = Error ||</span>
<span class="line" id="L13">    std.mem.Allocator.Error ||</span>
<span class="line" id="L14">    utils.StructReadError ||</span>
<span class="line" id="L15">    std.io.StreamSource.SeekError ||</span>
<span class="line" id="L16">    std.io.StreamSource.GetSeekPosError ||</span>
<span class="line" id="L17">    <span class="tok-kw">error</span>{ EndOfStream, StreamTooLong, InvalidData };</span>
<span class="line" id="L18"></span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = Error ||</span>
<span class="line" id="L20">    std.mem.Allocator.Error ||</span>
<span class="line" id="L21">    std.io.StreamSource.WriteError ||</span>
<span class="line" id="L22">    std.io.StreamSource.SeekError ||</span>
<span class="line" id="L23">    std.io.StreamSource.GetSeekPosError ||</span>
<span class="line" id="L24">    std.fs.File.OpenError ||</span>
<span class="line" id="L25">    <span class="tok-kw">error</span>{ EndOfStream, InvalidData, UnfinishedBits };</span>
<span class="line" id="L26"></span>
<span class="line" id="L27"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Format = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L28">    bmp,</span>
<span class="line" id="L29">    gif,</span>
<span class="line" id="L30">    jpg,</span>
<span class="line" id="L31">    pbm,</span>
<span class="line" id="L32">    pcx,</span>
<span class="line" id="L33">    pgm,</span>
<span class="line" id="L34">    png,</span>
<span class="line" id="L35">    ppm,</span>
<span class="line" id="L36">    qoi,</span>
<span class="line" id="L37">    tga,</span>
<span class="line" id="L38">    pam,</span>
<span class="line" id="L39">};</span>
<span class="line" id="L40"></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stream = std.io.StreamSource;</span>
<span class="line" id="L42"></span>
<span class="line" id="L43"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EncoderOptions = AllImageFormats.ImageEncoderOptions;</span>
<span class="line" id="L44"></span>
<span class="line" id="L45"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AnimationLoopInfinite = -<span class="tok-number">1</span>;</span>
<span class="line" id="L46"></span>
<span class="line" id="L47"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AnimationFrame = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L48">    pixels: color.PixelStorage,</span>
<span class="line" id="L49">    duration: <span class="tok-type">f32</span>,</span>
<span class="line" id="L50"></span>
<span class="line" id="L51">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: AnimationFrame, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L52">        self.pixels.deinit(allocator);</span>
<span class="line" id="L53">    }</span>
<span class="line" id="L54">};</span>
<span class="line" id="L55"></span>
<span class="line" id="L56"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Animation = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L57">    frames: FrameList = .{},</span>
<span class="line" id="L58">    loop_count: <span class="tok-type">i32</span> = AnimationLoopInfinite,</span>
<span class="line" id="L59"></span>
<span class="line" id="L60">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameList = std.ArrayListUnmanaged(AnimationFrame);</span>
<span class="line" id="L61"></span>
<span class="line" id="L62">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Animation, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L63">        <span class="tok-comment">// Animation share its first frame with the pixels in Image, we don't want to free it twice</span>
</span>
<span class="line" id="L64">        <span class="tok-kw">if</span> (self.frames.items.len &gt;= <span class="tok-number">2</span>) {</span>
<span class="line" id="L65">            <span class="tok-kw">for</span> (self.frames.items[<span class="tok-number">1</span>..]) |frame| {</span>
<span class="line" id="L66">                frame.pixels.deinit(allocator);</span>
<span class="line" id="L67">            }</span>
<span class="line" id="L68">        }</span>
<span class="line" id="L69"></span>
<span class="line" id="L70">        self.frames.deinit(allocator);</span>
<span class="line" id="L71">    }</span>
<span class="line" id="L72">};</span>
<span class="line" id="L73"></span>
<span class="line" id="L74"><span class="tok-comment">/// Format-independant image</span></span>
<span class="line" id="L75">allocator: std.mem.Allocator = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L76">width: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L77">height: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L78">pixels: color.PixelStorage = .{ .invalid = <span class="tok-type">void</span>{} },</span>
<span class="line" id="L79">animation: Animation = .{},</span>
<span class="line" id="L80"></span>
<span class="line" id="L81"><span class="tok-kw">const</span> Image = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L82"></span>
<span class="line" id="L83"><span class="tok-kw">const</span> FormatInteraceFnType = *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> () FormatInterface;</span>
<span class="line" id="L84"><span class="tok-kw">const</span> all_interface_funcs = blk: {</span>
<span class="line" id="L85">    <span class="tok-kw">const</span> allFormatDecls = std.meta.declarations(AllImageFormats);</span>
<span class="line" id="L86">    <span class="tok-kw">var</span> result: [allFormatDecls.len]FormatInteraceFnType = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L87">    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L88">    <span class="tok-kw">for</span> (allFormatDecls) |decl| {</span>
<span class="line" id="L89">        <span class="tok-kw">const</span> decl_value = <span class="tok-builtin">@field</span>(AllImageFormats, decl.name);</span>
<span class="line" id="L90">        <span class="tok-kw">const</span> entry_type = <span class="tok-builtin">@TypeOf</span>(decl_value);</span>
<span class="line" id="L91">        <span class="tok-kw">if</span> (entry_type == <span class="tok-type">type</span>) {</span>
<span class="line" id="L92">            <span class="tok-kw">const</span> entryTypeInfo = <span class="tok-builtin">@typeInfo</span>(decl_value);</span>
<span class="line" id="L93">            <span class="tok-kw">if</span> (entryTypeInfo == .Struct) {</span>
<span class="line" id="L94">                <span class="tok-kw">for</span> (entryTypeInfo.Struct.decls) |structEntry| {</span>
<span class="line" id="L95">                    <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, structEntry.name, <span class="tok-str">&quot;formatInterface&quot;</span>)) {</span>
<span class="line" id="L96">                        result[index] = <span class="tok-builtin">@field</span>(decl_value, structEntry.name);</span>
<span class="line" id="L97">                        index += <span class="tok-number">1</span>;</span>
<span class="line" id="L98">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L99">                    }</span>
<span class="line" id="L100">                }</span>
<span class="line" id="L101">            }</span>
<span class="line" id="L102">        }</span>
<span class="line" id="L103">    }</span>
<span class="line" id="L104"></span>
<span class="line" id="L105">    <span class="tok-kw">break</span> :blk result[<span class="tok-number">0</span>..index];</span>
<span class="line" id="L106">};</span>
<span class="line" id="L107"></span>
<span class="line" id="L108"><span class="tok-comment">/// Init an empty image with no pixel data</span></span>
<span class="line" id="L109"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator) Image {</span>
<span class="line" id="L110">    <span class="tok-kw">return</span> Image{</span>
<span class="line" id="L111">        .allocator = allocator,</span>
<span class="line" id="L112">    };</span>
<span class="line" id="L113">}</span>
<span class="line" id="L114"></span>
<span class="line" id="L115"><span class="tok-comment">/// Deinit the image</span></span>
<span class="line" id="L116"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Image) <span class="tok-type">void</span> {</span>
<span class="line" id="L117">    self.pixels.deinit(self.allocator);</span>
<span class="line" id="L118">    self.animation.deinit(self.allocator);</span>
<span class="line" id="L119">}</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-comment">/// Load an image from a file path</span></span>
<span class="line" id="L122"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromFilePath</span>(allocator: std.mem.Allocator, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Image {</span>
<span class="line" id="L123">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> std.fs.cwd().openFile(file_path, .{});</span>
<span class="line" id="L124">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L125"></span>
<span class="line" id="L126">    <span class="tok-kw">return</span> fromFile(allocator, &amp;file);</span>
<span class="line" id="L127">}</span>
<span class="line" id="L128"></span>
<span class="line" id="L129"><span class="tok-comment">/// Load an image from a standard library std.fs.File</span></span>
<span class="line" id="L130"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromFile</span>(allocator: std.mem.Allocator, file: *std.fs.File) !Image {</span>
<span class="line" id="L131">    <span class="tok-kw">var</span> stream_source = std.io.StreamSource{ .file = file.* };</span>
<span class="line" id="L132">    <span class="tok-kw">return</span> internalRead(allocator, &amp;stream_source);</span>
<span class="line" id="L133">}</span>
<span class="line" id="L134"></span>
<span class="line" id="L135"><span class="tok-comment">/// Load an image from a memory buffer</span></span>
<span class="line" id="L136"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromMemory</span>(allocator: std.mem.Allocator, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Image {</span>
<span class="line" id="L137">    <span class="tok-kw">var</span> stream_source = std.io.StreamSource{ .const_buffer = std.io.fixedBufferStream(buffer) };</span>
<span class="line" id="L138">    <span class="tok-kw">return</span> internalRead(allocator, &amp;stream_source);</span>
<span class="line" id="L139">}</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"><span class="tok-comment">/// Create a pixel surface from scratch</span></span>
<span class="line" id="L142"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(allocator: std.mem.Allocator, width: <span class="tok-type">usize</span>, height: <span class="tok-type">usize</span>, pixel_format: PixelFormat) !Image {</span>
<span class="line" id="L143">    <span class="tok-kw">const</span> result = Image{</span>
<span class="line" id="L144">        .allocator = allocator,</span>
<span class="line" id="L145">        .width = width,</span>
<span class="line" id="L146">        .height = height,</span>
<span class="line" id="L147">        .pixels = <span class="tok-kw">try</span> color.PixelStorage.init(allocator, pixel_format, width * height),</span>
<span class="line" id="L148">    };</span>
<span class="line" id="L149"></span>
<span class="line" id="L150">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L151">}</span>
<span class="line" id="L152"></span>
<span class="line" id="L153"><span class="tok-comment">/// Return the pixel format of the image</span></span>
<span class="line" id="L154"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pixelFormat</span>(self: Image) PixelFormat {</span>
<span class="line" id="L155">    <span class="tok-kw">return</span> std.meta.activeTag(self.pixels);</span>
<span class="line" id="L156">}</span>
<span class="line" id="L157"></span>
<span class="line" id="L158"><span class="tok-comment">/// Return the pixel data as a const byte slice. In case of an animation, it return the pixel data of the first frame.</span></span>
<span class="line" id="L159"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawBytes</span>(self: Image) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L160">    <span class="tok-kw">return</span> self.pixels.asBytes();</span>
<span class="line" id="L161">}</span>
<span class="line" id="L162"></span>
<span class="line" id="L163"><span class="tok-comment">/// Return the byte size of a row in the image</span></span>
<span class="line" id="L164"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rowByteSize</span>(self: Image) <span class="tok-type">usize</span> {</span>
<span class="line" id="L165">    <span class="tok-kw">return</span> self.imageByteSize() / self.height;</span>
<span class="line" id="L166">}</span>
<span class="line" id="L167"></span>
<span class="line" id="L168"><span class="tok-comment">/// Return the byte size of the whole image</span></span>
<span class="line" id="L169"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">imageByteSize</span>(self: Image) <span class="tok-type">usize</span> {</span>
<span class="line" id="L170">    <span class="tok-kw">return</span> self.rawBytes().len;</span>
<span class="line" id="L171">}</span>
<span class="line" id="L172"></span>
<span class="line" id="L173"><span class="tok-comment">/// Is this image is an animation?</span></span>
<span class="line" id="L174"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAnimation</span>(self: Image) <span class="tok-type">bool</span> {</span>
<span class="line" id="L175">    <span class="tok-kw">return</span> self.animation.frames.items.len &gt; <span class="tok-number">0</span>;</span>
<span class="line" id="L176">}</span>
<span class="line" id="L177"></span>
<span class="line" id="L178"><span class="tok-comment">/// Write the image to an image format to the specified path</span></span>
<span class="line" id="L179"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToFilePath</span>(self: Image, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, encoder_options: EncoderOptions) WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L180">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(file_path, .{});</span>
<span class="line" id="L181">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">    <span class="tok-kw">try</span> self.writeToFile(file, encoder_options);</span>
<span class="line" id="L184">}</span>
<span class="line" id="L185"></span>
<span class="line" id="L186"><span class="tok-comment">/// Write the image to an image format to the specified std.fs.File</span></span>
<span class="line" id="L187"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToFile</span>(self: Image, file: std.fs.File, encoder_options: EncoderOptions) WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L188">    <span class="tok-kw">var</span> stream_source = std.io.StreamSource{ .file = file };</span>
<span class="line" id="L189"></span>
<span class="line" id="L190">    <span class="tok-kw">try</span> self.internalWrite(&amp;stream_source, encoder_options);</span>
<span class="line" id="L191">}</span>
<span class="line" id="L192"></span>
<span class="line" id="L193"><span class="tok-comment">/// Write the image to an image format in a memory buffer. The memory buffer is not grown</span></span>
<span class="line" id="L194"><span class="tok-comment">/// for you so make sure you pass a large enough buffer.</span></span>
<span class="line" id="L195"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToMemory</span>(self: Image, write_buffer: []<span class="tok-type">u8</span>, encoder_options: EncoderOptions) WriteError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L196">    <span class="tok-kw">var</span> stream_source = std.io.StreamSource{ .buffer = std.io.fixedBufferStream(write_buffer) };</span>
<span class="line" id="L197"></span>
<span class="line" id="L198">    <span class="tok-kw">try</span> self.internalWrite(&amp;stream_source, encoder_options);</span>
<span class="line" id="L199"></span>
<span class="line" id="L200">    <span class="tok-kw">return</span> stream_source.buffer.getWritten();</span>
<span class="line" id="L201">}</span>
<span class="line" id="L202"></span>
<span class="line" id="L203"><span class="tok-comment">/// Iterate the pixel in pixel-format agnostic way. In the case of an animation, it returns an iterator for the first frame. The iterator is read-only.</span></span>
<span class="line" id="L204"><span class="tok-comment">// FIXME: *const Image is a workaround for a stage2 bug because determining the pass a parameter by value or pointer depending of the size is not mature yet</span>
</span>
<span class="line" id="L205"><span class="tok-comment">// and fails. For now we are explictly requesting to access only a const pointer.</span>
</span>
<span class="line" id="L206"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> Image) color.PixelStorageIterator {</span>
<span class="line" id="L207">    <span class="tok-kw">return</span> color.PixelStorageIterator.init(&amp;self.pixels);</span>
<span class="line" id="L208">}</span>
<span class="line" id="L209"></span>
<span class="line" id="L210"><span class="tok-kw">fn</span> <span class="tok-fn">internalRead</span>(allocator: std.mem.Allocator, stream: *Stream) !Image {</span>
<span class="line" id="L211">    <span class="tok-kw">const</span> format_interface = <span class="tok-kw">try</span> findImageInterfaceFromStream(stream);</span>
<span class="line" id="L212"></span>
<span class="line" id="L213">    <span class="tok-kw">try</span> stream.seekTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L214"></span>
<span class="line" id="L215">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> format_interface.readImage(allocator, stream);</span>
<span class="line" id="L216">}</span>
<span class="line" id="L217"></span>
<span class="line" id="L218"><span class="tok-kw">fn</span> <span class="tok-fn">internalWrite</span>(self: Image, stream: *Stream, encoder_options: EncoderOptions) WriteError!<span class="tok-type">void</span> {</span>
<span class="line" id="L219">    <span class="tok-kw">const</span> image_format = std.meta.activeTag(encoder_options);</span>
<span class="line" id="L220"></span>
<span class="line" id="L221">    <span class="tok-kw">var</span> format_interface = <span class="tok-kw">try</span> findImageInterfaceFromImageFormat(image_format);</span>
<span class="line" id="L222"></span>
<span class="line" id="L223">    <span class="tok-kw">try</span> format_interface.writeImage(self.allocator, stream, self, encoder_options);</span>
<span class="line" id="L224">}</span>
<span class="line" id="L225"></span>
<span class="line" id="L226"><span class="tok-kw">fn</span> <span class="tok-fn">findImageInterfaceFromStream</span>(stream: *Stream) !FormatInterface {</span>
<span class="line" id="L227">    <span class="tok-kw">for</span> (all_interface_funcs) |intefaceFn| {</span>
<span class="line" id="L228">        <span class="tok-kw">const</span> formatInterface = intefaceFn();</span>
<span class="line" id="L229"></span>
<span class="line" id="L230">        <span class="tok-kw">try</span> stream.seekTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L231">        <span class="tok-kw">const</span> found = <span class="tok-kw">try</span> formatInterface.formatDetect(stream);</span>
<span class="line" id="L232">        <span class="tok-kw">if</span> (found) {</span>
<span class="line" id="L233">            <span class="tok-kw">return</span> formatInterface;</span>
<span class="line" id="L234">        }</span>
<span class="line" id="L235">    }</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">    <span class="tok-kw">return</span> Error.Unsupported;</span>
<span class="line" id="L238">}</span>
<span class="line" id="L239"></span>
<span class="line" id="L240"><span class="tok-kw">fn</span> <span class="tok-fn">findImageInterfaceFromImageFormat</span>(image_format: Format) !FormatInterface {</span>
<span class="line" id="L241">    <span class="tok-kw">for</span> (all_interface_funcs) |interface_fn| {</span>
<span class="line" id="L242">        <span class="tok-kw">const</span> format_interface = interface_fn();</span>
<span class="line" id="L243"></span>
<span class="line" id="L244">        <span class="tok-kw">if</span> (format_interface.format() == image_format) {</span>
<span class="line" id="L245">            <span class="tok-kw">return</span> format_interface;</span>
<span class="line" id="L246">        }</span>
<span class="line" id="L247">    }</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">    <span class="tok-kw">return</span> Error.Unsupported;</span>
<span class="line" id="L250">}</span>
<span class="line" id="L251"></span>
</code></pre></body>
</html>